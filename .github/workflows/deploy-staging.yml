name: Deploy - Staging

on:
  push:
    branches: [ develop ]
  workflow_dispatch: {}

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_FRONTEND_REPO: "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/web-platform-frontend"
  ECR_BACKEND_REPO: "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/web-platform-backend"

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install deps
        run: |
          npm install
          npm run install:apps

      - name: Build apps
        run: npm run build

      # Configure AWS credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Login to ECR
      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      # Fetch secrets from AWS SSM Parameter Store
      # NOTE: In production, use External Secrets Operator or similar for better secret management
      - name: Fetch secrets from SSM and create Kubernetes secret
        run: |
          # Install kubectl if not available
          if ! command -v kubectl &> /dev/null; then
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          
          # Fetch secrets from SSM (example - adjust paths as needed)
          # DATABASE_URL should be in format: postgresql://user:pass@postgres:5432/db
          DATABASE_URL=$(aws ssm get-parameter \
            --name "/web-platform/staging/DATABASE_URL" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text 2>/dev/null || echo "postgresql://user:pass@postgres:5432/web_platform")
          
          AUTH_JWT_SECRET=$(aws ssm get-parameter \
            --name "/web-platform/staging/AUTH_JWT_SECRET" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text 2>/dev/null || echo "staging-secret-placeholder")
          
          # Create Kubernetes secret (if kubectl context is configured)
          # In CI, you would typically configure kubectl to point to your cluster
          if kubectl cluster-info &> /dev/null; then
            kubectl create secret generic backend-secrets \
              --from-literal=DATABASE_URL="${DATABASE_URL}" \
              --from-literal=AUTH_JWT_SECRET="${AUTH_JWT_SECRET}" \
              --namespace web-platform-staging \
              --dry-run=client -o yaml | kubectl apply -f - || true
          else
            echo "Kubectl not configured - skipping secret creation"
            echo "Secrets should be created manually or via External Secrets Operator"
          fi
        env:
          AWS_REGION: ${{ env.AWS_REGION }}

      - name: Build and push frontend image
        run: |
          FRONTEND_TAG="${ECR_FRONTEND_REPO}:staging-${GITHUB_SHA}"
          echo "Building frontend image: ${FRONTEND_TAG}"
          docker build \
            -t "${FRONTEND_TAG}" \
            apps/frontend-react
          docker push "${FRONTEND_TAG}"

      - name: Build and push backend image
        run: |
          BACKEND_TAG="${ECR_BACKEND_REPO}:staging-${GITHUB_SHA}"
          echo "Building backend image: ${BACKEND_TAG}"
          docker build \
            -t "${BACKEND_TAG}" \
            apps/backend-api
          docker push "${BACKEND_TAG}"

      - name: Deploy to Kubernetes via Helm
        run: |
          FRONTEND_TAG="staging-${GITHUB_SHA}"
          BACKEND_TAG="staging-${GITHUB_SHA}"

          helm upgrade --install web-platform \
            infra/helm/web-platform \
            --namespace web-platform-staging \
            --create-namespace \
            -f infra/helm/web-platform/values-staging.yaml \
            --set image.frontend.tag="${FRONTEND_TAG}" \
            --set image.backend.tag="${BACKEND_TAG}"

      - name: Wait for deployment to be ready
        run: |
          echo "Waiting for deployment to be ready..."
          max_attempts=60
          attempt=0
          STAGING_URL="${STAGING_BASE_URL:-https://staging.app.example.com}"
          while [ $attempt -lt $max_attempts ]; do
            if curl -f -s "${STAGING_URL}/healthz" > /dev/null 2>&1; then
              echo "Deployment is ready!"
              exit 0
            fi
            attempt=$((attempt + 1))
            echo "Attempt $attempt/$max_attempts: Deployment not ready yet, waiting..."
            sleep 10
          done
          echo "Deployment did not become ready in time"
          exit 1
        env:
          STAGING_BASE_URL: ${{ vars.STAGING_BASE_URL || 'https://staging.app.example.com' }}

      - name: Install test dependencies
        run: |
          if [ -d "tests/e2e" ]; then
            npx playwright install --with-deps chromium || true
          fi
          if [ -f "tests/contract/dredd.yml" ]; then
            npm install -g dredd || true
          fi
          if [ -f "tests/load/k6-api-smoke.js" ]; then
            K6_VERSION=v0.52.0
            curl -L "https://github.com/grafana/k6/releases/download/${K6_VERSION}/k6-${K6_VERSION}-linux-amd64.tar.gz" -o k6.tar.gz
            tar -xzf k6.tar.gz
            sudo mv k6-${K6_VERSION}-linux-amd64/k6 /usr/local/bin/k6
          fi

      - name: Run post-deploy validation checks
        run: |
          ENVIRONMENT=staging \
          BASE_URL="${STAGING_BASE_URL:-https://staging.app.example.com}" \
          make post-deploy-checks
        continue-on-error: true
        env:
          STAGING_BASE_URL: ${{ vars.STAGING_BASE_URL || 'https://staging.app.example.com' }}

      - name: Upload post-deploy report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: post-deploy-report-staging-${{ github.sha }}
          path: reports/post-deploy/*.md
          retention-days: 30
          if-no-files-found: warn

